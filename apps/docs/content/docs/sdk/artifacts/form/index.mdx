---
title: form
description: Create Form artifacts with fields, parties, and signing flows
---

Create Form artifacts for interactive forms with fields, signing parties, and document annexes.

# Examples

## Creating a form

```ts
// Object pattern
const form = open.form({
  name: 'lease-agreement',
  version: '1.0.0',
  title: 'Residential Lease Agreement',
  fields: {
    tenantName: { type: 'text', label: 'Tenant Name', required: true },
    moveInDate: { type: 'date', label: 'Move-in Date' },
    monthlyRent: { type: 'money', label: 'Monthly Rent', min: 0 }
  },
  parties: {
    tenant: { label: 'Tenant', partyType: 'person', signature: { required: true } },
    landlord: { label: 'Landlord', signature: { required: true, witnesses: 1 } }
  },
  annexes: {
    photoId: { title: 'Photo ID', required: true }
  },
  layers: {
    html: { kind: 'inline', mimeType: 'text/html', text: '<p>Tenant: {{tenantName}}</p>' }
  },
  defaultLayer: 'html'
})

// Builder pattern
const form = open.form()
  .name('lease-agreement')
  .version('1.0.0')
  .title('Residential Lease Agreement')
  .field('tenantName', field.text().label('Tenant Name').required().build())
  .field('moveInDate', field.date().label('Move-in Date').build())
  .field('monthlyRent', field.money().label('Monthly Rent').min(0).build())
  .party('tenant', party().label('Tenant').partyType('person')
    .signature({ required: true }).build())
  .party('landlord', party().label('Landlord')
    .signature({ required: true, witnesses: 1 }).build())
  .annex('photoId', annex().title('Photo ID').required().build())
  .inlineLayer('html', { mimeType: 'text/html', text: '<p>Tenant: {{tenantName}}</p>' })
  .defaultLayer('html')
  .build()
```

## Loading from external data

```ts
// Parse and validate unknown input (throws on error)
const form = open.form.from(jsonData)

// Safe parsing (returns result object)
const result = open.form.safeFrom(jsonData)
if (result.success) {
  const form = result.data
}
```

## Form Lifecycle

Forms follow a three-phase lifecycle: Draft → Signable → Executed.

```ts
// 1. Fill form to create DraftForm (mutable data)
const draft = form.fill({
  fields: { tenantName: 'John Doe', moveInDate: '2024-02-01' },
  parties: {
    tenant: { id: 'tenant-0', fullName: 'John Doe' },
    landlord: { id: 'landlord-0', legalName: 'ABC Property LLC' }
  }
})

// 2. Configure signers and signatories
const ready = draft
  .addSigner('john', {
    person: { fullName: 'John Doe' },
    adopted: { signature: { image: 'data:...', method: 'drawn' } }
  })
  .addSignatory('tenant', 'tenant-0', { signerId: 'john' })

// 3. Prepare for signing (SignableForm - data frozen)
const signable = ready.prepareForSigning()

// 4. Capture signatures
const signed = signable.captureSignature('tenant', 'tenant-0', 'john', 'final-sig')

// 5. Finalize (ExecutedForm - fully frozen)
const executed = signed.finalize()

// 6. Render the executed form
const output = await executed.render({ renderer: textRenderer })
```

# API

## Object Pattern

```ts
open.form(input: FormInput): FormInstance
```

### Parameters

<PropertiesTable properties={[
  { name: 'name', type: 'string', description: 'Unique identifier; must follow slug constraints' },
  { name: 'version', type: 'string', description: 'Artifact version (semantic versioning)', isOptional: true },
  { name: 'title', type: 'string', description: 'Human-friendly name presented to end users', isOptional: true },
  { name: 'description', type: 'string', description: 'Long-form description or context', isOptional: true },
  { name: 'code', type: 'string', description: 'Internal code or reference number', isOptional: true },
  { name: 'releaseDate', type: 'string', description: 'ISO date when artifact was released', isOptional: true },
  { name: 'metadata', type: 'Metadata', description: 'Custom metadata map', isOptional: true },
  { name: 'logic', type: 'LogicSection', description: 'Named expressions for conditional logic', isOptional: true },
  { name: 'fields', type: 'Record<string, FormField>', description: 'Field definitions keyed by identifier', isOptional: true },
  { name: 'layers', type: 'Record<string, Layer>', description: 'Named layers for rendering', isOptional: true },
  { name: 'defaultLayer', type: 'string', description: 'Key of default layer for rendering', isOptional: true },
  { name: 'annexes', type: 'Record<string, FormAnnex>', description: 'Predefined annex slots keyed by identifier', isOptional: true },
  { name: 'allowAdditionalAnnexes', type: 'boolean', description: 'Allow ad-hoc annexes beyond defined slots', isOptional: true },
  { name: 'parties', type: 'Record<string, FormParty>', description: 'Party role definitions', isOptional: true },
]} />

### Returns

Returns a `FormInstance` with the following properties and methods:

<PropertiesTable properties={[
  { name: 'kind', type: "'form'", description: 'Artifact discriminator' },
  { name: 'name', type: 'string', description: 'Form name' },
  { name: 'version', type: 'string | undefined', description: 'Semantic version' },
  { name: 'title', type: 'string | undefined', description: 'Human-readable title' },
  { name: 'description', type: 'string | undefined', description: 'Description text' },
  { name: 'code', type: 'string | undefined', description: 'Internal code' },
  { name: 'releaseDate', type: 'string | undefined', description: 'ISO date string' },
  { name: 'metadata', type: 'Metadata | undefined', description: 'Custom metadata map' },
  { name: 'logic', type: 'LogicSection | undefined', description: 'Named logic expressions' },
  { name: 'fields', type: 'Record<string, FormField> | undefined', description: 'Field definitions' },
  { name: 'layers', type: 'Record<string, Layer> | undefined', description: 'Render layers' },
  { name: 'defaultLayer', type: 'string | undefined', description: 'Default layer key' },
  { name: 'annexes', type: 'Record<string, FormAnnex> | undefined', description: 'Annex slot definitions' },
  { name: 'allowAdditionalAnnexes', type: 'boolean | undefined', description: 'Allow ad-hoc annexes' },
  { name: 'parties', type: 'Record<string, FormParty> | undefined', description: 'Party role definitions' },
  { name: 'parseData', type: '(data: Record<string, unknown>) => InferFormPayload', description: 'Validate data against form (throws on error)', isMethod: true },
  { name: 'safeParseData', type: '(data: Record<string, unknown>) => ValidationResult', description: 'Validate data (returns result object)', isMethod: true },
  { name: 'fill', type: '(data: FillOptions) => DraftForm', description: 'Create a DraftForm with validated data', isMethod: true },
  { name: 'safeFill', type: '(data: FillOptions) => Result<DraftForm>', description: 'Create DraftForm (returns result object)', isMethod: true },
  { name: 'render', type: '(options: RenderOptions) => Promise<Output>', description: 'Render using a renderer', isMethod: true },
  { name: 'clone', type: '() => FormInstance', description: 'Deep clone the instance', isMethod: true },
  { name: 'validate', type: '(options?: ValidateOptions) => StandardSchemaV1.Result', description: 'Validate the form definition', isMethod: true },
  { name: 'isValid', type: '(options?: ValidateOptions) => boolean', description: 'Check if form is valid', isMethod: true },
  { name: 'toJSON', type: '(options?: SerializationOptions) => object', description: 'Serialize to JSON', isMethod: true },
  { name: 'toYAML', type: '(options?: SerializationOptions) => string', description: 'Serialize to YAML', isMethod: true },
]} />

## Builder Pattern

Chain methods to build a form incrementally:

<MethodChain
  starter="open.form()"
  methods={[
    { name: 'name', params: 'value: string', description: 'Set form name (required)' },
    { name: 'version', params: 'value: string', description: 'Set semantic version' },
    { name: 'title', params: 'value: string', description: 'Set human-readable title' },
    { name: 'description', params: 'value: string', description: 'Set description' },
    { name: 'code', params: 'value: string', description: 'Set external reference code' },
    { name: 'releaseDate', params: 'value: string', description: 'Set release date (ISO format)' },
    { name: 'metadata', params: 'value: Metadata', description: 'Set custom metadata' },
    { name: 'logic', params: 'value: LogicSection', description: 'Set logic expressions' },
    { name: 'expr', params: 'name: string, expression: string', description: 'Add a single logic expression' },
    { name: 'field', params: 'id: string, field: FormField', description: 'Add a single field' },
    { name: 'fields', params: 'fields: Record<string, FormField>', description: 'Set all fields at once' },
    { name: 'layers', params: 'value: Record<string, Layer>', description: 'Set all layers at once' },
    { name: 'layer', params: 'key: string, layer: Layer', description: 'Add a layer' },
    { name: 'inlineLayer', params: 'key: string, layer: { mimeType, text, ... }', description: 'Add inline text layer' },
    { name: 'fileLayer', params: 'key: string, layer: { mimeType, path, ... }', description: 'Add file-backed layer' },
    { name: 'defaultLayer', params: 'key: string', description: 'Set default layer for rendering' },
    { name: 'annex', params: 'annexId: string, annex: FormAnnex', description: 'Add a single annex slot' },
    { name: 'annexes', params: 'annexes: Record<string, FormAnnex>', description: 'Set all annexes at once' },
    { name: 'allowAdditionalAnnexes', params: 'value: boolean', description: 'Allow ad-hoc annexes' },
    { name: 'party', params: 'roleId: string, party: FormParty', description: 'Add a party role' },
    { name: 'parties', params: 'parties: Record<string, FormParty>', description: 'Set all parties at once' },
    { name: 'build', params: '', description: 'Build and validate', terminal: true },
  ]}
  returns={{ intermediate: 'FormBuilder', terminal: 'FormInstance' }}
/>

## Static Methods

Parse forms from unknown data sources:

<MethodTable methods={[
  { name: 'from', params: 'input: unknown', returns: 'FormInstance', description: 'Parse unknown input (throws on error)' },
  { name: 'safeFrom', params: 'input: unknown', returns: 'Result<FormInstance>', description: 'Parse unknown input (returns result object)' },
]} />

# Data Validation

FormInstance provides Zod-style methods for validating data:

```ts
// Throws FormValidationError if validation fails
const validated = form.parseData({ fields: { tenantName: 'John' } })

// Returns result object
const result = form.safeParseData({ fields: { tenantName: 'John' } })
if (result.success) {
  console.log(result.data)
} else {
  console.error(result.errors)
}
```

# Lifecycle Types

The `fill()` method returns a `DraftForm` that follows the form lifecycle:

| Type | Phase | Data | Signatures |
|------|-------|------|------------|
| `DraftForm` | Draft | Mutable | Configure signers/signatories |
| `SignableForm` | Signable | Frozen | Capture signatures |
| `ExecutedForm` | Executed | Frozen | Frozen (complete) |

## DraftForm

Created by `form.fill()`. Mutable data and signer configuration.

<PropertiesTable properties={[
  { name: 'phase', type: "'draft'", description: 'Phase discriminator' },
  { name: 'form', type: 'Form', description: 'The embedded form definition' },
  { name: 'data', type: 'InferFormPayload', description: 'The validated data payload' },
  { name: 'parties', type: 'Record<string, Party | Party[]>', description: 'Party data by role ID' },
  { name: 'signers', type: 'Record<string, Signer>', description: 'Global signer registry' },
  { name: 'signatories', type: 'Record<string, Record<string, PartySignatory[]>>', description: 'Signatories by role/party' },
  { name: 'targetLayer', type: 'string', description: 'Current rendering layer' },
  { name: 'runtimeState', type: 'FormRuntimeState', description: 'Evaluated logic state' },
  { name: 'getField', type: '(fieldId: string) => T | undefined', description: 'Get a field value', isMethod: true },
  { name: 'getAllFields', type: '() => Record<string, unknown>', description: 'Get all field values', isMethod: true },
  { name: 'setField', type: '(fieldId: string, value: T) => DraftForm', description: 'Update a field (immutable)', isMethod: true },
  { name: 'updateFields', type: '(partial: Record<string, unknown>) => DraftForm', description: 'Update multiple fields', isMethod: true },
  { name: 'getParty', type: '(roleId: string) => Party | Party[] | undefined', description: 'Get party for role', isMethod: true },
  { name: 'setParty', type: '(roleId: string, party: Party | Party[]) => DraftForm', description: 'Set party (immutable)', isMethod: true },
  { name: 'addParty', type: '(roleId: string, party: Party) => DraftForm', description: 'Add party to role', isMethod: true },
  { name: 'addSigner', type: '(signerId: string, signer: Signer) => DraftForm', description: 'Add signer to registry', isMethod: true },
  { name: 'addSignatory', type: '(roleId, partyId, signatory) => DraftForm', description: 'Link signer to party', isMethod: true },
  { name: 'prepareForSigning', type: '() => SignableForm', description: 'Transition to signable phase', isMethod: true },
  { name: 'seal', type: '(adapter: Sealer) => Promise<SignableForm>', description: 'Seal for formal e-signing', isMethod: true },
  { name: 'render', type: '(options: RenderOptions) => Promise<Output>', description: 'Render with embedded data', isMethod: true },
  { name: 'toJSON', type: '() => DraftFormJSON', description: 'Serialize to JSON', isMethod: true },
  { name: 'toYAML', type: '() => string', description: 'Serialize to YAML', isMethod: true },
]} />

## SignableForm

Created by `draft.prepareForSigning()` or `draft.seal()`. Frozen data, signature capture allowed.

<PropertiesTable properties={[
  { name: 'phase', type: "'signable'", description: 'Phase discriminator' },
  { name: 'isFormal', type: 'boolean', description: 'True if created via seal()' },
  { name: 'signatureMap', type: 'SigningField[] | undefined', description: 'Signature field coordinates (formal only)' },
  { name: 'canonicalPdfHash', type: 'string | undefined', description: 'PDF hash (formal only)' },
  { name: 'captures', type: 'SignatureCapture[]', description: 'Captured signatures' },
  { name: 'witnesses', type: 'WitnessParty[]', description: 'Declared witnesses' },
  { name: 'attestations', type: 'Attestation[]', description: 'Witness attestations' },
  { name: 'captureSignature', type: '(role, partyId, signerId, locationId, options?) => SignableForm', description: 'Capture signature at location', isMethod: true },
  { name: 'captureInitials', type: '(role, partyId, signerId, locationId, options?) => SignableForm', description: 'Capture initials at location', isMethod: true },
  { name: 'addWitness', type: '(witness: WitnessParty) => SignableForm', description: 'Add a witness', isMethod: true },
  { name: 'addAttestation', type: '(attestation: Attestation) => SignableForm', description: 'Add attestation', isMethod: true },
  { name: 'getSignatureStatus', type: '(roleId: string) => SignatureStatus', description: 'Get status for role', isMethod: true },
  { name: 'getOverallSignatureStatus', type: '() => OverallSignatureStatus', description: 'Get overall progress', isMethod: true },
  { name: 'finalize', type: '() => ExecutedForm', description: 'Transition to executed phase', isMethod: true },
]} />

## ExecutedForm

Created by `signable.finalize()`. Fully frozen, ready for archival.

<PropertiesTable properties={[
  { name: 'phase', type: "'executed'", description: 'Phase discriminator' },
  { name: 'executedAt', type: 'string', description: 'ISO timestamp of execution' },
  { name: 'getCaptures', type: '() => SignatureCapture[]', description: 'Get all captures', isMethod: true },
  { name: 'getWitnesses', type: '() => WitnessParty[]', description: 'Get all witnesses', isMethod: true },
  { name: 'getAttestations', type: '() => Attestation[]', description: 'Get all attestations', isMethod: true },
  { name: 'render', type: '(options: RenderOptions) => Promise<Output>', description: 'Render the executed form', isMethod: true },
  { name: 'toJSON', type: '() => ExecutedFormJSON', description: 'Serialize to JSON', isMethod: true },
]} />

# Related

- [field](/sdk/artifacts/form/field) - Field definitions
- [annex](/sdk/artifacts/form/annex) - Annex slot definitions
- [party](/sdk/artifacts/form/party) - Party role definitions
- [Form Schema](/schemas/artifacts/form)
